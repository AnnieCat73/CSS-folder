/* reset */
 
*,
*::before,
*::after {
  box-sizing: border-box;
}

h1,
.h1,
h2,
.h2,
h3,
.h3,
h4,
.h4 {
  line-height: 1;
}

body,
h1,
h2,
h3,
p,
dl,
dd,
figure {
  margin: 0;
}

ul[class],
ol[class] {
  list-style: none;
  padding: 0;
}

input,
button,
textarea,
select {
  font: inherit;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
 }

body {
  line-height: 1.6;
  font-family: Verdana, Geneva, Tahoma, sans-serif;
  max-width: 1440px;
  margin: 0 auto;
}

section {
  padding: 3rem 0;
}

h2 {
  margin-bottom: 1.5rem;
}

h3 {
  margin-bottom: 1rem;
}



/*Focus*

When we interact with one of these elements (either by clicking on it or tabbing to it), it becomes focused. It'll capture keyboard input, so we can type into a form field or press "Enter" to follow a link.

The :focus pseudo-class allows us to apply styles exclusively when an interactive element has focus:

For most users, a button can be focused by clicking on it. Focus can then be moved between buttons by pressing “Tab” (to go forward) or “Shift” + “Tab” (to go backwards).

Focus styles are primarily useful for folks who don't use a "pointer-style" input device (like a mouse, a trackpad, or a finger on a touchscreen). For example, I built the foundations of this course platform without the use of a keyboard/mouse, due to a repetitive stress injury; initially, I did all of my navigation by voice, speaking "tab" into a microphone to move between focused elements. The focus styles show you where you are on the page, which element is selected.

Fortunately, browsers do come with default focus styles. It varies by browser, but it's typically either a blue or dotted outline. */

/*:checked

The :checked pseudo-class only applies to checkboxes and radio buttons that are "filled in". You can apply additional styles to indicate that the input is activated:

Browsers don't offer too much flexibility when it comes to checkboxes and radio buttons, but this neat trick lets you apply certain CSS properties depending on its status.*/

input:checked {
  width: 24px;
  height: 24px;
}


/*first/last child

Pseudo-classes aren't just for states like hover/focus/checked! They can also help us apply conditional logic.

The :last-child pseudo-class will only select <p> tags which are the final element within its container. It needs to be the last child within its parent.

Similarly, the :first-child pseudo-class will match the first child within a parent container. */

li:first-child {
  color: red;
}

li:last-child {
  color: green;
}


/*:first-of-type and :last-of-type

In addition to :first-child and :last-child, we also have :first-of-type and :last-of-type. They're almost identical, but they have one critical difference.

:first-of-type depends on the type of the HTML tag.*/

 p:first-of-type {
    color: red;
  }


/*Pseudo-elements

Pseudo-elements are like pseudo-classes, but they don't target a specific state. Instead, they target "sub-elements" within an element.

For example, we can style the placeholder text in a form input with ::placeholder

In terms of syntax, pseudo-elements use two colons instead of one (::), though some pseudo-elements also support single-colon syntax.

If we stop and think about it, something pretty interesting is happening here. We haven't explicitly created a <placeholder> element, but by adding the placeholder attribute to the <input> tag, a pseudo-element is created.

This is why they're called pseudo-elements — these selectors target elements in the DOM that we haven't explicitly created with HTML tags.

Placeholders are criticized because the text is typically very light; if someone has poor vision, they might not be able to read the text at all.

Here's the thing, though: placeholders aren't meant to contain critical information. They're meant to provide an example, to give folks an idea about how to format their data. They should never be used to label an input (use a <label> element instead).

What if the user can't read the placeholder, and enters data in an incorrect format? First, we should build forms that are flexible and support a wide range of user inputs. With the power of JavaScript, we can transform their input into a standardized format!

But, if they really do enter invalid data, a helpful error message should be shown. It should explain what the user did wrong, and how to fix it. And it should be bright and high-contrast.

Here's a quick test you can use to check if you're using placeholders correctly: if you were to remove all of the placeholders from the form, would it still be usable, and easy to fill out? If the answer is “no”, you have some work to do.*/


input {
  font-size: 1rem;
}
input::placeholder {
  color: goldenrod;
}
