/* reset */
 
*,
*::before,
*::after {
  box-sizing: border-box;
}

h1,
.h1,
h2,
.h2,
h3,
.h3,
h4,
.h4 {
  line-height: 1;
}

body,
h1,
h2,
h3,
p,
dl,
dd,
figure {
  margin: 0;
}

ul[class],
ol[class] {
  list-style: none;
  padding: 0;
}

input,
button,
textarea,
select {
  font: inherit;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
 }

body {
  line-height: 1.6;
  font-family: Verdana, Geneva, Tahoma, sans-serif;
  max-width: 1440px;
  margin: 3rem auto;
}

section {
  padding: 3rem 0;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 2rem;
}

h2 {
  margin-bottom: 1.5rem;
}

h3 {
  margin-bottom: 1rem;
}

.m-top {
  margin-top: 3.5rem;
}
.m-bottom {
  margin-bottom: 2rem;
}


/*POSITIONED LAYOUT

Static positioning
The default value of the position property is static.

Occasionally, you'll see tutorials refer to "statically-positioned" elements. All this really means is that the elements are not using Positioned layout; they're using some other layout mode, like Flow or Flexbox or Grid.

If an element is currently using Positioned layout and you want to opt out, you can set position to either static or initial:

.box {
  /* Revert to its default value, which is ‘static’ *
  position: initial;
}


RELATIVE POSITIONING

You can often slap position: relative on an element, and observe zero difference. It appears to have no effect!

In fact, it does two things:

Constrains certain children (we'll get to this shortly!)
Enables additional CSS properties to be used.
When we opt into Positioned layout, we enable a handful of new CSS properties, including:

top
left
right
bottom

We can use those directional values to shift the element around. With relative positioning, those values are relative to its natural position.

You can also use negative numbers to push the element in the opposite direction; for relatively-positioned nodes, left: -10px has the same effect as right: 10px.

The big difference is that position doesn't impact layout. Notice in the visualization that the grey boxes above and below (representing sibling elements) don't move; they don't get pulled along for the ride, as they do with margin.

When we push a relatively-positioned element around with top/left/right/bottom, the browser acts like the element is still in its original position. The displacement is purely cosmetic.

Finally, it's important to note that relative positioning can be applied to both block and inline elements. This allows us to nudge inline elements in a way that isn't really possible otherwise.


ABSOLUTE POSITION

What if we want to take an element out of this orderly flow, and stick it wherever we want?

We generally use absolute positioning for things like:

UI elements that need to float above the UI, like tooltips or dropdowns.
Decorative elements that need to be stuck in certain positions (eg. abstract illustrations).
Stacking multiple elements in the same place, like a deck of cards.

Absolutely-positioned elements are adjusted based on their container, not based on their in-flow position.

If we don't give our absolute element an anchor (i.e top, left etc), it sits in its default in-flow position. I think of it as "inheriting" its default position from Flow layout.

When we set something to be position: absolute, we pull it out of flow.

When the browser is laying out elements, it effectively pretends that absolutely-positioned elements don't exist. They're “incorporeal”: you can stick your hand right through them, like a hologram or a ghost.

The browser starts by putting that first paragraph in its natural position, at the top of the document, but because it's absolute, it still considers that space empty.

Next, the second paragraph gets added in its natural position, which is also right at the top, since the container is effectively “empty”.

This process will continue for each provided absolute element.

Being able to take elements out-of-flow is super handy. Any time you want an element to be "floating above" the content, like a tooltip or a dropdown or a modal, absolute positioning is your friend.

When we toggle on that position: absolute, you'll notice that the parent "collapses" down, so that it's 8px tall (4px top border, 4px bottom).

Why does this happen? Well, in terms of flow layout, the parent is empty! Remember, absolute elements are like holograms, they don't really exist. And since this parent element has no other children, it's as if it was an empty div: */

.child1 {
  /* Toggle this property: */
  position: absolute;
  width: 200px;
  height: 200px;
  background: pink;
  opacity: 0.5;
}

.parent1 {
  border: 4px solid;
}

/*IN GENERAL, absolute positioning is intended to be used in situations where we don't want it to affect its surrounding layout.


CENTERING TRICK IN absolute: position so can use margin: 0 auto;

absolute positioning (position: absolute)
Equal distances from each edge (ideally 0px)
A fixed size (defined width and height properties)
Hungry margins (margin: auto)

.box {
  position: absolute;
  top: 0px;
  left: 0px;
  right: 0px;
  bottom: 0px;
  width: 100px;
  height: 100px;
  margin: auto;
  background: deeppink;
}


THE INSET PROPERTY

As we saw, the centering trick requires setting all 4 edge properties to the same value:

.box {
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
This feels very tedious, and modern CSS has given us a more terse way to accomplish this:

.box {
  inset: 0;
}

or

.box {
  position: absolute;
  inset: 25px;
  background: deeppink;
}

This is equivalent to:

.box {
  position: absolute;
  top: 25px;
  left: 25px;
  right: 25px;
  bottom: 25px;
  background: deeppink;
}


CONTAINING BLOCKS

In CSS, every HTML element has a “containing block”. A containing block is a rectangle that forms the bounds of the element's container.

In Flow layout, elements are contained by their parents. For example, this paragraph is contained by its parent <section>

<section class="container">
  <p>Hello World!</p>
</section>

.container {
  width: 200px;
  border: 5px solid;
  padding: 16px;
}

To be precise: the paragraph is contained by a “containing block” the size and shape of the parent element's content box