/* reset */
 
*,
*::before,
*::after {
  box-sizing: border-box;
}

h1,
.h1,
h2,
.h2,
h3,
.h3,
h4,
.h4 {
  line-height: 1;
}

body,
h1,
h2,
h3,
p,
dl,
dd,
figure {
  margin: 0;
}

ul[class],
ol[class] {
  list-style: none;
  padding: 0;
}

input,
button,
textarea,
select {
  font: inherit;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
 }

body {
  line-height: 1.6;
  font-family: Verdana, Geneva, Tahoma, sans-serif;
  max-width: 1440px;
  margin: 3rem auto;
}

section {
  padding: 3rem 0;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 2rem;
}

h2 {
  margin-bottom: 1.5rem;
}

h3 {
  margin-bottom: 1rem;
}

.m-top {
  margin-top: 3.5rem;
}
.m-bottom {
  margin-bottom: 2rem;
}


/*POSITIONED LAYOUT

Static positioning
The default value of the position property is static.

Occasionally, you'll see tutorials refer to "statically-positioned" elements. All this really means is that the elements are not using Positioned layout; they're using some other layout mode, like Flow or Flexbox or Grid.

If an element is currently using Positioned layout and you want to opt out, you can set position to either static or initial:

.box {
  /* Revert to its default value, which is ‘static’ *
  position: initial;
}


RELATIVE POSITIONING

You can often slap position: relative on an element, and observe zero difference. It appears to have no effect!

In fact, it does two things:

Constrains certain children (we'll get to this shortly!)
Enables additional CSS properties to be used.
When we opt into Positioned layout, we enable a handful of new CSS properties, including:

top
left
right
bottom

We can use those directional values to shift the element around. With relative positioning, those values are relative to its natural position.

You can also use negative numbers to push the element in the opposite direction; for relatively-positioned nodes, left: -10px has the same effect as right: 10px.

The big difference is that position doesn't impact layout. Notice in the visualization that the grey boxes above and below (representing sibling elements) don't move; they don't get pulled along for the ride, as they do with margin.

When we push a relatively-positioned element around with top/left/right/bottom, the browser acts like the element is still in its original position. The displacement is purely cosmetic.

Finally, it's important to note that relative positioning can be applied to both block and inline elements. This allows us to nudge inline elements in a way that isn't really possible otherwise.